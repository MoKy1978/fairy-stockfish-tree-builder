<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tree Viewer</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  font-family: 'Segoe UI', sans-serif;
  background: #fafafa;
  margin: 0;
  padding: 2vh 2vw;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
.container {
  display: flex;
  height: 100%;
  width: 100%;
}
.board-section {
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  max-height: 100%;
  align-items: center;
}
.board-area {
  display: flex;
  align-items: stretch;
  flex-shrink: 0;
}
.board-container {
  width: calc(min(85vh, 85vw));
  height: calc(min(85vh, 85vw));
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
#board {
  display: grid;
}
.bank {
  display: flex;
  flex-direction: column;
  gap: calc(min(0.6vh, 0.5vw));
  padding: 8px 4px;
  width: calc(min(8vh, 6vw));
  flex-shrink: 0;
  align-items: center;
}
.bank#whiteBank {
  flex-direction: column-reverse;
  justify-content: flex-start;
}
.bank#blackBank {
  justify-content: flex-start;
}
.bank-piece {
  line-height: 1;
  text-align: center;
}
.square {
  display: flex;
  align-items: center;
  justify-content: center;
}
.square.light { background: #f0d9b5; }
.square.dark { background: #d2b08c; }
.controls {
  display: grid;
  grid-template-columns: auto auto auto;
  align-items: center;
  gap: calc(min(3vh, 2vw));
  margin-top: calc(min(0.8vh, 0.5vw));
  flex-shrink: 0;
  width: calc(min(85vh, 65vw));
}
.nav-buttons {
  display: flex;
  gap: calc(min(3vh, 3vw));
  justify-self: center;
}
#btnCopyFen {
  justify-self: start;
}
#btnCopyId {
  justify-self: end;
}
.control-btn {
  width: calc(min(10vh, 8vw));
  height: calc(min(10vh, 8vw));
  cursor: pointer;
  font-size: calc(min(10vh, 8vw));
  display: flex;
  align-items: center;
  justify-content: center;
}
.control-btn:hover:not(.disabled) {
  opacity: 0.6;
}
.control-btn.disabled {
  opacity: 0.3;
  cursor: not-allowed;
  pointer-events: none;
}
.side {
  width: calc(min(90vh, 80vw));
  display: flex;
  flex-direction: column;
  max-height: 100%;
  overflow: hidden;
  font-family: monospace;
  font-size: calc(min(6.5vh, 6vw));
}
.moves {
  display: flex;
  flex-direction: column;
  padding: 0px;
  gap: calc(min(1vh, 0.8vw));
  overflow-y: scroll;
  scrollbar-width: none;
  flex: 1;
}
.move {
  display: flex;
  padding: calc(min(1vh, 0.8vw)) calc(min(3vh, 2vw));
  background: #fafafa;
  border: 1px solid #e0e0e0;
  cursor: pointer;
  transition: all 0.2s;
}
.move:hover {
  background: #e8e8e8;
}
.move.best {
  background: #c8e6c9;
  border-color: #4caf50;
}
.move.worst {
  background: #ffcdd2;
  border-color: #f44336;
}
.terminal {
  padding: calc(min(1vh, 0.8vw)) calc(min(3vh, 2vw));
  background: #ffcdd2;
  border: 1px solid #f44336;
  color: #c62828;
}
.move-name {
  flex: 0.8;
  text-align: left;
}
.move-eval {
  flex: 1;
  text-align: right;
  color: #333;
}
.move-credit {
  flex: 0.5;
  text-align: right;
  color: #999;
}
.load {
  margin-top: calc(min(0.6vh, 0.5vw));
  flex-shrink: 0;
  display: flex;
  gap: calc(min(0.6vh, 0.5vw));
  font-size: calc(min(5vh, 4vw));
  text-align: center;
}
.load #btnLoad,
.load #btnReload {
  padding: calc(min(1vh, 0.8vw)) calc(min(1vh, 0.8vw));
  background: #fff;
  border: 1px solid #ddd;
  cursor: pointer;
  flex: 1;
}
.load #btnLoad:hover,
.load #btnReload:hover {
  background: #f0f0f0;
}
.load #btnReload.disabled {
  opacity: 0.3;
  cursor: not-allowed;
  pointer-events: none;
}
.status {
  position: fixed;
  bottom: 12vh;
  right: 2vw;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: calc(min(1vh, 0.8vw)) calc(min(3vh, 2vw));
  border-radius: calc(min(1vh, 0.8vw));
  font-size: calc(min(5vh, 4vw));
  display: none;
  z-index: 10;
}
.status.show {
  display: block;
}
@media (max-width: 768px) {
  .container {
    flex-direction: column;
    align-items: center;
    gap: 1vh;
  }
  .board-section {
    width: 100%;
    flex-shrink: 1;
  }
  .board-container {
    width: calc(min(90vh, 85vw));
    height: calc(min(90vh, 85vw));
  }
  .controls {
    width: calc(min(80vh, 70vw));
  }
  .side {
    width: 90%;
    height: 40vh;
    max-height: none;
    flex-shrink: 1;
  }
  .moves {
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
}
</style>
</head>
<body>

<div class="status" id="status"></div>

<div class="container">
  <div class="board-section">
    <div class="board-area">
      <div class="bank" id="whiteBank"></div>
      <div class="board-container">
        <div id="board"></div>
      </div>
      <div class="bank" id="blackBank"></div>
    </div>
    <div class="controls">
      <div class="control-btn" id="btnCopyFen" title="">üìã</div>
      <div class="nav-buttons">
        <div class="control-btn" id="btnStart" title="Start">‚Æú</div>
        <div class="control-btn" id="btnBack" title="Back">‚óÄ</div>
        <div class="control-btn" id="btnForward" title="Forward">‚ñ∂</div>
        <div class="control-btn" id="btnEnd" title="End">‚Æû</div>
      </div>
      <div class="control-btn" id="btnCopyId" title="">üÜî</div>
    </div>
  </div>

  <div class="side">
    <div class="moves" id="moves"></div>
    <div class="load">
      <div id="btnLoad">Load File</div>
      <div id="btnReload" class="disabled">Reload</div>
    </div>
  </div>
</div>

<script>
let positions = {};
let currentId = 0;
let history = [];
let fileHandle = null;

const pieces = {
  'K':'‚ôî','Q':'‚ôï','R':'‚ôñ','B':'‚ôó','N':'‚ôò','P':'‚ôô',
  'k':'‚ôö','q':'‚ôõ','r':'‚ôú','b':'‚ôù','n':'‚ôû','p':'‚ôü',
  'W':'‚ôñ','F':'‚ôó','H':'‚ôò',
  'w':'‚ôú','f':'‚ôù','h':'‚ôû',
};

function showStatus(msg) {
  document.getElementById('status').textContent = msg;
  document.getElementById('status').classList.add('show');
}

function hideStatus() {
  document.getElementById('status').classList.remove('show');
}

async function loadFile(file) {
  const startTime = Date.now();
  const text = await file.text();
  const lines = text.split('\n');
  
  let loaded = 0;
  const total = lines.length;
  
  // Dynamick√Ω batch size
  const batchSize = total < 1000 ? 100 : total < 100000 ? 5000 : 50000;
  let nextUpdate = Math.min(100, total);
  
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (!line) continue;
    
    // Handle CRLF
    if (line.endsWith('\r')) line = line.slice(0, -1);
    line = line.trim();
    if (!line) continue;
    
    const s1 = line.indexOf(';');
    const s2 = line.indexOf(';', s1 + 1);
    const s3 = line.indexOf(';', s2 + 1);
    const s4 = line.indexOf(';', s3 + 1);
    const s5 = line.indexOf(';', s4 + 1);
    
    if (s1 === -1 || s2 === -1 || s3 === -1 || s4 === -1 || s5 === -1) continue;
    
    const id = parseInt(line.substring(0, s1), 10);
    const fen = line.substring(s1 + 1, s2);
    const movesStr = line.substring(s2 + 1, s3);
    const moves = movesStr ? movesStr.split(',') : [];
    
    const evalsStr = line.substring(s3 + 1, s4);
    const evals = [];
    if (evalsStr) {
      let start = 0;
      for (let j = 0; j <= evalsStr.length; j++) {
        if (j === evalsStr.length || evalsStr[j] === ',') {
          evals.push(parseInt(evalsStr.substring(start, j), 10));
          start = j + 1;
        }
      }
    }
    
    const childIdsStr = line.substring(s4 + 1, s5);
    const child_ids = [];
    if (childIdsStr) {
      let start = 0;
      for (let j = 0; j <= childIdsStr.length; j++) {
        if (j === childIdsStr.length || childIdsStr[j] === ',') {
          child_ids.push(parseInt(childIdsStr.substring(start, j), 10));
          start = j + 1;
        }
      }
    }
    
    const moves_complete = line.charAt(s5 + 1) === '1';
    
    positions[id] = { fen, moves, evals, child_ids, moves_complete };
    loaded++;
    
    // Update UI periodicky
    if (loaded >= nextUpdate) {
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      const rate = Math.round(loaded / (Date.now() - startTime) * 1000 / 1000);
      showStatus(`${loaded} in ${elapsed}s (${rate}k/s)`);
      
      if (loaded === nextUpdate && nextUpdate <= 100) {
        currentId = 0;
        history = [];
        updateDisplay();
        document.getElementById('btnReload').classList.remove('disabled');
      }
      
      nextUpdate = loaded + batchSize;
      
      // Yield to UI
      await new Promise(r => setTimeout(r, 0));
    }
  }
  
  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  const rate = Math.round(loaded / (Date.now() - startTime) * 1000 / 1000);
  showStatus(`${loaded} in ${elapsed}s (${rate}k/s) ‚úì`);
  
  if (loaded > 0) {
    if (!positions[currentId]) {
      currentId = 0;
      history = [];
    }
    updateDisplay();
    document.getElementById('btnReload').classList.remove('disabled');
  }
  
  setTimeout(hideStatus, 3000);
  return true;
}

function drawBoard(fen) {
  const board = document.getElementById('board');
  const whiteBank = document.getElementById('whiteBank');
  const blackBank = document.getElementById('blackBank');
  
  board.innerHTML = '';
  whiteBank.innerHTML = '';
  blackBank.innerHTML = '';
  
  const parts = fen.split(' ');
  let positionPart = parts[0];
  let bank = null;
  
  if (positionPart.includes('[')) {
    const bankStart = positionPart.indexOf('[');
    bank = positionPart.substring(bankStart + 1, positionPart.indexOf(']'));
    positionPart = positionPart.substring(0, bankStart);
  }
  
  const rows = positionPart.split('/');
  const ranks = rows.length;
  // Remove tildes before counting files
  const files = rows[0].replace(/~/g, '').replace(/[^1-8a-zA-Z]/g, '').split('').reduce((sum, c) => 
    sum + (isNaN(c) ? 1 : parseInt(c)), 0
  );
  
  const containerSize = Math.min(
    document.querySelector('.board-container').offsetWidth,
    document.querySelector('.board-container').offsetHeight
  );
  const squareSize = Math.floor(containerSize / Math.max(ranks, files));
  
  board.style.gridTemplateColumns = `repeat(${files}, ${squareSize}px)`;
  board.style.gridTemplateRows = `repeat(${ranks}, ${squareSize}px)`;
  
  for (let r = 0; r < ranks; r++) {
    const row = rows[r];
    let f = 0;
    
    for (let i = 0; i < row.length; i++) {
      const char = row[i];
      
      // Skip tilde (promotion marker)
      if (char === '~') continue;
      
      if (!isNaN(char)) {
        for (let j = 0; j < parseInt(char); j++) {
          const sq = document.createElement('div');
          sq.className = `square ${(r + f) % 2 === 0 ? 'light' : 'dark'}`;
          sq.style.width = `${squareSize}px`;
          sq.style.height = `${squareSize}px`;
          board.appendChild(sq);
          f++;
        }
      } else {
        const sq = document.createElement('div');
        sq.className = `square ${(r + f) % 2 === 0 ? 'light' : 'dark'}`;
        sq.style.width = `${squareSize}px`;
        sq.style.height = `${squareSize}px`;
        sq.style.fontSize = `${squareSize * 0.85}px`;
        
        sq.textContent = pieces[char] || '';
        
        board.appendChild(sq);
        f++;
      }
    }
  }
  
  if (bank) {
    for (let char of bank) {
      if (pieces[char] || char.match(/[A-Za-z]/)) {
        const piece = document.createElement('div');
        piece.className = 'bank-piece';
        piece.textContent = pieces[char] || char;
        piece.style.fontSize = `${squareSize * 0.4}px`;
        
        if (char === char.toUpperCase()) {
          whiteBank.appendChild(piece);
        } else {
          blackBank.appendChild(piece);
        }
      }
    }
  }
}

function formatEval(evalValue) {
  const MATE_BASE = 30000;
  if (evalValue > MATE_BASE - 100) {
    return `M${MATE_BASE - evalValue}`;
  } else if (evalValue < -(MATE_BASE - 100)) {
    return `-M${MATE_BASE + evalValue}`;
  }
  return evalValue >= 0 ? `+${evalValue}` : `${evalValue}`;
}

function updateDisplay() {
  const pos = positions[currentId];
  
  if (!pos) {
    console.error('Position not found:', currentId);
    return;
  }
  
  document.getElementById('btnCopyFen').title = `Copy FEN: ${pos.fen}`;
  document.getElementById('btnCopyId').title = `Copy ID: ${currentId}`;
  
  drawBoard(pos.fen);
  
  const movesDiv = document.getElementById('moves');
  movesDiv.innerHTML = '';
  
  if (!pos.moves || pos.moves.length === 0) {
    if (pos.moves_complete) {
      const terminalDiv = document.createElement('div');
      terminalDiv.className = 'terminal';
      terminalDiv.textContent = 'Terminal';
      movesDiv.appendChild(terminalDiv);
    }
    updateButtons();
    return;
  }
  
  const moveData = pos.moves.map((move, i) => ({
    move: move,
    eval: pos.evals[i],
    childId: pos.child_ids[i],
    originalIdx: i
  }));
  
  moveData.sort((a, b) => b.eval - a.eval);
  
  const bestEval = moveData[0].eval;
  const worstEval = moveData[moveData.length - 1].eval;
  
  for (let i = 0; i < moveData.length; i++) {
    const data = moveData[i];
    const moveDiv = document.createElement('div');
    moveDiv.className = 'move';
    
    if (data.eval === bestEval) {
      moveDiv.classList.add('best');
    } else if (data.eval === worstEval && pos.moves_complete && moveData.length > 1) {
      moveDiv.classList.add('worst');
    }
    
    const evalStr = formatEval(data.eval);
    const creditStr = data.childId < 0 ? '‚óã' : '';
    
    moveDiv.innerHTML = `
      <span class="move-name">${data.move}</span>
      <span class="move-eval">${evalStr}</span>
      <span class="move-credit">${creditStr}</span>
    `;
    
    if (data.childId >= 0) {
      moveDiv.onclick = () => {
        history.push(currentId);
        currentId = data.childId;
        updateDisplay();
      };
    } else {
      moveDiv.style.opacity = '0.5';
      moveDiv.style.cursor = 'not-allowed';
    }
    
    movesDiv.appendChild(moveDiv);
  }
  
  updateButtons();
}

function updateButtons() {
  const canGoBack = history.length > 0;
  document.getElementById('btnBack').classList.toggle('disabled', !canGoBack);
  document.getElementById('btnStart').classList.toggle('disabled', !canGoBack);
  
  const pos = positions[currentId];
  let canGoForward = false;
  if (pos && pos.moves && pos.moves.length > 0) {
    let bestIdx = 0;
    let bestEval = pos.evals[0];
    for (let i = 1; i < pos.evals.length; i++) {
      if (pos.evals[i] > bestEval) {
        bestEval = pos.evals[i];
        bestIdx = i;
      }
    }
    const childId = pos.child_ids[bestIdx];
    canGoForward = (childId !== null && childId !== undefined && childId >= 0);
  }
  
  document.getElementById('btnForward').classList.toggle('disabled', !canGoForward);
  document.getElementById('btnEnd').classList.toggle('disabled', !canGoForward);
}

document.getElementById('btnStart').onclick = () => {
  if (history.length > 0) {
    currentId = 0;
    history = [];
    updateDisplay();
  }
};

document.getElementById('btnBack').onclick = () => {
  if (history.length > 0) {
    currentId = history.pop();
    updateDisplay();
  }
};

document.getElementById('btnForward').onclick = () => {
  const pos = positions[currentId];
  if (!pos || !pos.moves || pos.moves.length === 0) return;
  
  let bestIdx = 0;
  let bestEval = pos.evals[0];
  for (let i = 1; i < pos.evals.length; i++) {
    if (pos.evals[i] > bestEval) {
      bestEval = pos.evals[i];
      bestIdx = i;
    }
  }
  
  const childId = pos.child_ids[bestIdx];
  if (childId !== null && childId !== undefined && childId >= 0) {
    history.push(currentId);
    currentId = childId;
    updateDisplay();
  }
};

document.getElementById('btnEnd').onclick = () => {
  let maxDepth = 100;
  let depth = 0;
  
  while (depth < maxDepth) {
    const pos = positions[currentId];
    if (!pos || !pos.moves || pos.moves.length === 0) break;
    
    let bestIdx = 0;
    let bestEval = pos.evals[0];
    for (let i = 1; i < pos.evals.length; i++) {
      if (pos.evals[i] > bestEval) {
        bestEval = pos.evals[i];
        bestIdx = i;
      }
    }
    
    const childId = pos.child_ids[bestIdx];
    if (childId === null || childId === undefined || childId < 0) break;
    
    history.push(currentId);
    currentId = childId;
    depth++;
  }
  
  updateDisplay();
};

document.getElementById('btnCopyFen').onclick = () => {
  const pos = positions[currentId];
  if (pos) {
    navigator.clipboard.writeText(pos.fen);
    showStatus('FEN copied!');
    setTimeout(hideStatus, 3000);
  }
};

document.getElementById('btnCopyId').onclick = () => {
  navigator.clipboard.writeText(currentId.toString());
  showStatus('ID copied!');
  setTimeout(hideStatus, 3000);
};

document.getElementById('btnLoad').onclick = async () => {
  try {
    const [handle] = await window.showOpenFilePicker({
      types: [{
        description: 'EPD Files',
        accept: {'*/*': ['.epd', '.txt']}
      }],
      multiple: false
    });
    
    fileHandle = handle;
    const file = await fileHandle.getFile();
    positions = {};
    
    await loadFile(file);
  } catch (error) {
    if (error.name !== 'AbortError') {
      console.error('File picker error:', error);
      showStatus('Error opening file');
      setTimeout(hideStatus, 3000);
    }
  }
};

document.getElementById('btnReload').onclick = async () => {
  if (!fileHandle) return;
  
  try {
    const savedId = currentId;
    const savedHistory = [...history];
    showStatus('Reloading...');
    const file = await fileHandle.getFile();
    positions = {};
    await loadFile(file);
    if (positions[savedId]) {
      currentId = savedId;
      history = savedHistory;
      updateDisplay();
    }
  } catch (error) {
    console.error('Reload error:', error);
    showStatus('Error reloading');
    setTimeout(hideStatus, 3000);
  }
};

document.getElementById('btnStart').classList.add('disabled');
document.getElementById('btnBack').classList.add('disabled');
document.getElementById('btnForward').classList.add('disabled');
document.getElementById('btnEnd').classList.add('disabled');

document.getElementById('btnCopyFen').title = 'Copy FEN';
document.getElementById('btnCopyId').title = 'Copy ID: 0';

document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
    return;
  }
  
  switch(e.key) {
    case 'ArrowLeft':
      e.preventDefault();
      if (history.length > 0) {
        document.getElementById('btnBack').click();
      }
      break;
      
    case 'ArrowRight':
      e.preventDefault();
      if (!document.getElementById('btnForward').classList.contains('disabled')) {
        document.getElementById('btnForward').click();
      }
      break;
      
    case 'ArrowUp':
    case 'Home':
      e.preventDefault();
      if (history.length > 0) {
        document.getElementById('btnStart').click();
      }
      break;
      
    case 'ArrowDown':
    case 'End':
      e.preventDefault();
      if (!document.getElementById('btnEnd').classList.contains('disabled')) {
        document.getElementById('btnEnd').click();
      }
      break;
  }
});

let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (positions[currentId]) {
      drawBoard(positions[currentId].fen);
    }
  }, 200);
});
</script>
</body>
</html>