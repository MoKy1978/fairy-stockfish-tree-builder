# -*- coding: utf-8 -*-
"""perfect-tree-explorer

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HGmq2eWwMqLbVpO69FSZrJiBbCAserTY
"""

import os, sys, subprocess, shutil, time
from pathlib import Path

ENGINE       = "/content/stockfish"
VARIANT      = "tinyhouse"  #@param ["chess", "atomic", "antichess", "crazyhouse", "3check", "racingkings", "horde", "tinyhouse"]
THREADS      = 4            #@param {type:"integer"}
HASHMB       = 4096         #@param {type:"integer"}
DEPTH = 30           #@param {type:"integer"}

from google.colab import drive
drive.mount('/content/drive/')

DIR = f'/content/drive/MyDrive/trees/{VARIANT}/'
os.makedirs(DIR, exist_ok=True)

EPD  = f'{VARIANT}.epd'
LOG  = f'{VARIANT}.log'

INI = None
if os.path.exists('/content/drive/MyDrive/trees/variants.ini'):
    shutil.copy('/content/drive/MyDrive/trees/variants.ini', '/content/')
    INI = '/content/variants.ini'

NNUE = None
for file in Path(DIR).glob('*.nnue'):
    shutil.copy(file, '/content/')
    NNUE = f'/content/{file.name}'
    break

if os.path.exists(f'{DIR}{EPD}'):
    shutil.copy(f'{DIR}{EPD}', f'/content/{EPD}')

if os.path.exists(f'{DIR}{LOG}'):
    shutil.copy(f'{DIR}{LOG}', f'/content/{LOG}')

if os.path.exists('/content/drive/MyDrive/trees/stockfish'):
    shutil.copy('/content/drive/MyDrive/trees/stockfish', '/content/')
    os.chmod('/content/stockfish', 0o755)
else:
    subprocess.run(['git', 'clone', 'https://github.com/fairy-stockfish/Fairy-Stockfish.git', '/content/Fairy-Stockfish/'], check=True)
    subprocess.run(['make', 'clean'], cwd='/content/Fairy-Stockfish/src/', check=True)
    subprocess.run(['make', 'ARCH=x86-64-modern', 'COMP=gcc', 'all', '-j2'], cwd='/content/Fairy-Stockfish/src/', check=True)
    shutil.copy('/content/Fairy-Stockfish/src/stockfish', '/content/')
    shutil.copy('/content/stockfish', '/content/drive/MyDrive/trees/')

import subprocess

class Engine:
    def __init__(self):
        self.process = subprocess.Popen(
            [ENGINE],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            bufsize=0
        )

        self.send_command("uci")
        self.read_until("uciok")

        if INI:
            self.send_command(f"load {INI}")
        self.send_command(f"setoption name UCI_Variant value {VARIANT}")

        if NNUE:
            self.send_command(f"setoption name EvalFile value {NNUE}")
            self.send_command("setoption name Use NNUE value true")

        self.send_command(f"setoption name Threads value {THREADS}")
        self.send_command(f"setoption name Hash value {HASHMB}")
        self.send_command(f"setoption name MultiPV value 1")
        self.send_command("setoption name UCI_AnalyseMode value true")

    def send_command(self, command: str):
        if self.process.poll() is None:
            try:
                self.process.stdin.write(f"{command}\n")
                self.process.stdin.flush()
            except (OSError, BrokenPipeError, ValueError):
                pass

    def read_until(self, terminator: str) -> list[str]:
        lines = []
        while True:
            line = self.process.stdout.readline().strip()
            if not line and self.process.poll() is not None:
                break
            lines.append(line)
            if terminator in line:
                break
        return lines

    def get_fen(self, position_cmd: str = "position startpos") -> str:
        self.send_command(position_cmd)
        self.send_command("d")
        for line in self.read_until("Fen:"):
            if "Fen: " in line:
                return ' '.join(line.split()[1:3])
        raise RuntimeError(f"Failed to get FEN for: {position_cmd}")

    def get_perft_moves(self, fen: str) -> list[str]:
        self.send_command(f"position fen {fen}")
        self.send_command("go perft 1")
        lines = self.read_until("Nodes searched:")

        moves = []
        for line in lines:
            if ':' in line and not line.startswith("Nodes"):
                move = line.split(':')[0].strip()
                moves.append(move)
        return moves

    def get_best_move(self, fen: str, searchmoves: list[str] = None) -> tuple[str, int] | None:
        self.send_command(f"position fen {fen}")

        cmd = f"go depth {DEPTH}"
        if searchmoves:
            cmd += " searchmoves " + " ".join(searchmoves)

        self.send_command(cmd)
        lines = self.read_until("bestmove")

        best_move = None
        for line in reversed(lines):
            if line.startswith("bestmove"):
                if "(none)" in line:
                    return None
                best_move = line.split()[1]
                break

        if not best_move:
            return None

        for line in reversed(lines):
            if line.startswith("info") and "score" in line:
                parts = line.split()
                for i, part in enumerate(parts):
                    if part == "score" and i+2 < len(parts):
                        score_type = parts[i+1]
                        score_value = int(parts[i+2])
                        if score_type == "cp":
                            return (best_move, score_value)
                        elif score_type == "mate":
                            score = (30000 - score_value) if score_value > 0 else (-30000 - score_value)
                            return (best_move, score)

        return None

    def shut_down(self):
        if self.process.poll() is None:
            try:
                self.send_command("quit")
            except (OSError, BrokenPipeError):
                pass
            self.process.terminate()
            self.process.wait()

from pathlib import Path

class Tree:
    """
    Node structure:
        fen: str              - position (board + side to move only)
        moves: list[str]      - analyzed moves in UCI notation
        evals: list[int]      - centipawn evaluations (29999 = mate in 1)
        child_ids: list[int]  - node IDs (-1 = not yet expanded)
        best_idx: int         - index of move with highest eval
        moves_complete: bool  - all legal moves are in 'moves' list
    """

    def __init__(self):
        self.engine = Engine()

        self.nodes = {}
        self.fen_to_id = {}
        self.node_count = 0
        self.root_id = 0
        self.cycle = 0

        self.load_epd()
        self.load_log()

    def load_epd(self):
        epd_path = Path(EPD)
        if not epd_path.exists():
            print("Creating new tree")
            root_fen = self.engine.get_fen()
            self.root_id = self.create_node(root_fen)
            return

        with open(epd_path, 'r') as f:
            for line in f:
                if not line.strip():
                    continue

                parts = line.strip().split(';')
                if len(parts) < 6:
                    continue

                node_id = int(parts[0])
                fen = parts[1]
                moves = parts[2].split(',') if parts[2] else []
                evals = [int(x) for x in parts[3].split(',')] if parts[3] else []
                child_ids = [int(x) for x in parts[4].split(',')] if parts[4] else []
                moves_complete = parts[5] == '1' if len(parts) > 5 else False

                best_idx = 0
                if evals:
                    best_idx = max(range(len(evals)), key=evals.__getitem__)

                self.nodes[node_id] = {
                    'fen': fen,
                    'moves': moves,
                    'evals': evals,
                    'child_ids': child_ids,
                    'best_idx': best_idx,
                    'moves_complete': moves_complete
                }

                self.fen_to_id[fen] = node_id
                self.node_count = max(self.node_count, node_id + 1)

        print(f"Loaded {self.node_count} nodes")

    def save_epd(self):
        temp_path = Path(EPD + '.tmp')
        epd_path = Path(EPD)

        with open(temp_path, 'w', newline='\n') as f:
            for node_id in range(self.node_count):
                if node_id not in self.nodes:
                    continue

                node = self.nodes[node_id]
                fen = node['fen']
                moves = ','.join(node['moves'])
                evals = ','.join(str(e) for e in node['evals'])
                children = ','.join(str(c) for c in node['child_ids'])
                complete = '1' if node['moves_complete'] else '0'

                f.write(f"{node_id};{fen};{moves};{evals};{children};{complete};\n")

        os.replace(temp_path, epd_path)
        shutil.copy(f'/content/{EPD}', f'{DIR}{EPD}')

    def load_log(self):
        log_path = Path(LOG)
        if not log_path.exists():
            return

        try:
            with open(log_path, 'r') as f:
                lines = f.readlines()
                for line in reversed(lines):
                    if line.startswith("=== Cycle"):
                        self.cycle = int(line.split()[2])
                        break
            print(f"Resuming cycle {self.cycle}")
        except Exception as e:
            print(f"Warning: Could not load log: {e}")

    def create_node(self, fen: str) -> int | None:
        result = self.engine.get_best_move(fen)
        if result is None:
            return self.create_terminal_node(fen)

        best_move, best_score = result

        all_moves = self.engine.get_perft_moves(fen)

        other_moves = [m for m in all_moves if m != best_move]

        moves = [best_move]
        evals = [best_score]
        child_ids = [-1]

        if other_moves:
            alt_result = self.engine.get_best_move(fen, searchmoves=other_moves)
            if alt_result:
                alt_move, alt_score = alt_result
                moves.append(alt_move)
                evals.append(alt_score)
                child_ids.append(-1)

        node_id = self.node_count
        self.node_count += 1

        best_idx = max(range(len(evals)), key=evals.__getitem__)

        self.nodes[node_id] = {
            'fen': fen,
            'moves': moves,
            'evals': evals,
            'child_ids': child_ids,
            'best_idx': best_idx,
            'moves_complete': len(moves) == len(all_moves)
        }

        self.fen_to_id[fen] = node_id
        return node_id

    def create_terminal_node(self, fen: str) -> int:
        node_id = self.node_count
        self.node_count += 1

        self.nodes[node_id] = {
            'fen': fen,
            'moves': [],
            'evals': [],
            'child_ids': [],
            'best_idx': 0,
            'moves_complete': True
        }

        self.fen_to_id[fen] = node_id
        return node_id

    def add_alternative(self, node_id: int):
        node = self.nodes[node_id]

        if node['moves_complete']:
            return

        fen = node['fen']
        all_moves = self.engine.get_perft_moves(fen)
        analyzed_moves = set(node['moves'])
        unanalyzed_moves = [m for m in all_moves if m not in analyzed_moves]

        if not unanalyzed_moves:
            node['moves_complete'] = True
            return

        result = self.engine.get_best_move(fen, searchmoves=unanalyzed_moves)
        if result is None:
            node['moves_complete'] = True
            return

        move, move_eval = result

        node['moves'].append(move)
        node['evals'].append(move_eval)
        node['child_ids'].append(-1)

        if move_eval > node['evals'][node['best_idx']]:
            node['best_idx'] = len(node['moves']) - 1

        if len(node['moves']) == len(all_moves):
            node['moves_complete'] = True

    def expand_move(self, node_id: int, move_idx: int) -> int | None:
        node = self.nodes[node_id]
        fen = node['fen']
        move = node['moves'][move_idx]
        move_eval = node['evals'][move_idx]

        child_fen = self.engine.get_fen(f"position fen {fen} moves {move}")

        if child_fen in self.fen_to_id:
            child_id = self.fen_to_id[child_fen]
            node['child_ids'][move_idx] = child_id
            return child_id

        if move_eval == 29999:
            child_id = self.create_terminal_node(child_fen)
        else:
            child_id = self.create_node(child_fen)

        if child_id is not None:
            node['child_ids'][move_idx] = child_id

        return child_id

    def backpropagate_evals(self):
        last_changed = [0] * self.node_count
        iteration = 0
        any_changed = True

        while any_changed:
            any_changed = False

            for node_id in reversed(range(self.node_count)):
                node = self.nodes[node_id]
                edge_changed = False

                for edge_idx in range(len(node['moves'])):
                    child_id = node['child_ids'][edge_idx]
                    if child_id >= 0 and last_changed[child_id] == iteration:
                        child = self.nodes[child_id]
                        if len(child['moves']) > 0:
                            child_best_idx = child['best_idx']
                            child_eval = child['evals'][child_best_idx]
                            old_eval = node['evals'][edge_idx]
                            negamax = -child_eval
                            if negamax < 0:
                                negamax += 2
                            new_eval = negamax - 1

                            if new_eval != old_eval:
                                node['evals'][edge_idx] = new_eval
                                edge_changed = True

                if edge_changed:
                    evals = node['evals']
                    node['best_idx'] = max(range(len(evals)), key=evals.__getitem__)
                    last_changed[node_id] += 1
                    any_changed = True

            iteration += 1

        print(f"Backpropagation converged in {iteration} iterations")

    def extend_principal_variation(self) -> str:
        line = []
        node_id = self.root_id
        visited = set()

        while True:
            if node_id in visited:
                line.append("[LOOP]")
                print("[LOOP]", flush=True)
                break
            visited.add(node_id)

            node = self.nodes[node_id]

            if not node['moves_complete'] and -1 not in node['child_ids']:
                self.add_alternative(node_id)

            num_edges = len(node['moves'])
            if num_edges == 0:
                line.append("[TERMINAL]")
                print("[TERMINAL]", flush=True)
                break

            best_idx = node['best_idx']
            move = node['moves'][best_idx]
            move_eval = node['evals'][best_idx]

            line.append(f"{move}({move_eval:+d})")

            child_id = node['child_ids'][best_idx]

            if child_id == -1:
                child_id = self.expand_move(node_id, best_idx)
                if child_id is None:
                    break
                print(f"{move}({move_eval:+d}) ", end='', flush=True)
                self.save_epd()
                node_id = child_id
            elif child_id >= 0:
                print(f"{move}({move_eval:+d}) ", end='', flush=True)
                node_id = child_id
            else:
                break

        return ' '.join(line)

    def explore(self):
        try:
            while True:
                principal_variation = self.extend_principal_variation()
                self.backpropagate_evals()

                root_node = self.nodes[self.root_id]
                root_eval = root_node['evals'][root_node['best_idx']]

                log_msg = f"\n=== Cycle {self.cycle} ===\n{principal_variation}\nNodes: {self.node_count}\nRoot: {root_eval:+d}\n"
                print(log_msg, end='', flush=True)

                with open(LOG, 'a', newline='\n') as f:
                    f.write(log_msg)
                shutil.copy(f'/content/{LOG}', f'{DIR}{LOG}')

                self.save_epd()
                self.cycle += 1

        except KeyboardInterrupt:
            print("\nInterrupted by user")
        except Exception as e:
            print(f"Error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.save_epd()
            self.engine.shut_down()

tree = Tree()
tree.explore()